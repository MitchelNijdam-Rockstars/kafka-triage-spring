package com.mnijdam.kafkatriage.bdobjekts.public

import com.dbobjekts.api.AnyColumn
import com.dbobjekts.api.TableRowData
import com.dbobjekts.metadata.Table
import com.dbobjekts.metadata.column.AutoKeyLongColumn
import com.dbobjekts.metadata.column.BooleanColumn
import com.dbobjekts.metadata.column.IntegerColumn
import com.dbobjekts.metadata.column.LongColumn
import com.dbobjekts.metadata.column.NullableLongColumn
import com.dbobjekts.metadata.column.NullableVarcharColumn
import com.dbobjekts.metadata.column.VarcharColumn
import com.dbobjekts.statement.WriteQueryAccessors
import com.dbobjekts.statement.insert.InsertBuilderBase
import com.dbobjekts.statement.update.HasUpdateBuilder
import com.dbobjekts.statement.update.UpdateBuilderBase

/**           
 * Auto-generated metadata object for db table public.record.
 *
 * Do not edit this file manually! Always use [com.dbobjekts.codegen.CodeGenerator] when the metadata model is no longer in sync with the database.           
 *
 * Primary keys: id
 *
 * Foreign keys to: 
 * References by: public.header
 */
object Record:Table<RecordRow>("record"), HasUpdateBuilder<RecordUpdateBuilder, RecordInsertBuilder> {
    /**
     * Represents db column public.record.id
     */
    val id = AutoKeyLongColumn(this, "id")
    /**
     * Represents db column public.record.key
     */
    val key = NullableVarcharColumn(this, "key")
    /**
     * Represents db column public.record.offset
     */
    val offset = LongColumn(this, "offset")
    /**
     * Represents db column public.record.partition
     */
    val partition = IntegerColumn(this, "partition")
    /**
     * Represents db column public.record.replayed_offset
     */
    val replayedOffset = NullableLongColumn(this, "replayed_offset")
    /**
     * Represents db column public.record.timestamp
     */
    val timestamp = LongColumn(this, "timestamp")
    /**
     * Represents db column public.record.topic
     */
    val topic = VarcharColumn(this, "topic")
    /**
     * Represents db column public.record.triaged
     */
    val triaged = BooleanColumn(this, "triaged")
    /**
     * Represents db column public.record.value
     */
    val value = NullableVarcharColumn(this, "value")
    override val columns: List<AnyColumn> = listOf(id,key,offset,partition,replayedOffset,timestamp,topic,triaged,value)
    override fun toValue(values: List<Any?>) = RecordRow(values[0] as Long,values[1] as String?,values[2] as Long,values[3] as Int,values[4] as Long?,values[5] as Long,values[6] as String,values[7] as Boolean,values[8] as String?)
    override fun metadata(): WriteQueryAccessors<RecordUpdateBuilder, RecordInsertBuilder> = WriteQueryAccessors(RecordUpdateBuilder(), RecordInsertBuilder())
}

class RecordUpdateBuilder() : UpdateBuilderBase(Record) {
    fun key(value: String?): RecordUpdateBuilder = put(Record.key, value)
    fun offset(value: Long): RecordUpdateBuilder = put(Record.offset, value)
    fun partition(value: Int): RecordUpdateBuilder = put(Record.partition, value)
    fun replayedOffset(value: Long?): RecordUpdateBuilder = put(Record.replayedOffset, value)
    fun timestamp(value: Long): RecordUpdateBuilder = put(Record.timestamp, value)
    fun topic(value: String): RecordUpdateBuilder = put(Record.topic, value)
    fun triaged(value: Boolean): RecordUpdateBuilder = put(Record.triaged, value)
    fun value(value: String?): RecordUpdateBuilder = put(Record.value, value)
    
    /**
     * FOR INTERNAL USE ONLY
     */
    override fun updateRow(rowData: TableRowData<*, *>): Long {
      rowData as RecordRow
      add(Record.id, rowData.id)
      add(Record.key, rowData.key)
      add(Record.offset, rowData.offset)
      add(Record.partition, rowData.partition)
      add(Record.replayedOffset, rowData.replayedOffset)
      add(Record.timestamp, rowData.timestamp)
      add(Record.topic, rowData.topic)
      add(Record.triaged, rowData.triaged)
      add(Record.value, rowData.value)
      return where(Record.id.eq(rowData.id))
    }    
        
}

class RecordInsertBuilder():InsertBuilderBase(){
    fun key(value: String?): RecordInsertBuilder = put(Record.key, value)
    fun offset(value: Long): RecordInsertBuilder = put(Record.offset, value)
    fun partition(value: Int): RecordInsertBuilder = put(Record.partition, value)
    fun replayedOffset(value: Long?): RecordInsertBuilder = put(Record.replayedOffset, value)
    fun timestamp(value: Long): RecordInsertBuilder = put(Record.timestamp, value)
    fun topic(value: String): RecordInsertBuilder = put(Record.topic, value)
    fun triaged(value: Boolean): RecordInsertBuilder = put(Record.triaged, value)
    fun value(value: String?): RecordInsertBuilder = put(Record.value, value)

    fun mandatoryColumns(offset: Long, partition: Int, timestamp: Long, topic: String, triaged: Boolean) : RecordInsertBuilder {
      mandatory(Record.offset, offset)
      mandatory(Record.partition, partition)
      mandatory(Record.timestamp, timestamp)
      mandatory(Record.topic, topic)
      mandatory(Record.triaged, triaged)
      return this
    }


    override fun insertRow(rowData: TableRowData<*, *>): Long {
      rowData as RecordRow
      add(Record.key, rowData.key)
      add(Record.offset, rowData.offset)
      add(Record.partition, rowData.partition)
      add(Record.replayedOffset, rowData.replayedOffset)
      add(Record.timestamp, rowData.timestamp)
      add(Record.topic, rowData.topic)
      add(Record.triaged, rowData.triaged)
      add(Record.value, rowData.value)
      return execute()
    }    
        
}


data class RecordRow(
val id: Long = 0,
  val key: String?,
  val offset: Long,
  val partition: Int,
  val replayedOffset: Long?,
  val timestamp: Long,
  val topic: String,
  val triaged: Boolean,
  val value: String?    
) : TableRowData<RecordUpdateBuilder, RecordInsertBuilder>(Record.metadata()){
     override val primaryKeys = listOf<Pair<AnyColumn, Any?>>(Pair(Record.id, id))
}
        

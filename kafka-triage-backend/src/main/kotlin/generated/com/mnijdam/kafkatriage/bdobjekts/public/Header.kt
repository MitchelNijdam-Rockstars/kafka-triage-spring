package com.mnijdam.kafkatriage.bdobjekts.public

import com.dbobjekts.api.AnyColumn
import com.dbobjekts.api.TableRowData
import com.dbobjekts.metadata.Table
import com.dbobjekts.metadata.column.AutoKeyLongColumn
import com.dbobjekts.metadata.column.ForeignKeyLongColumn
import com.dbobjekts.metadata.column.NullableBooleanColumn
import com.dbobjekts.metadata.column.NullableVarcharColumn
import com.dbobjekts.statement.WriteQueryAccessors
import com.dbobjekts.statement.insert.InsertBuilderBase
import com.dbobjekts.statement.update.HasUpdateBuilder
import com.dbobjekts.statement.update.UpdateBuilderBase

/**           
 * Auto-generated metadata object for db table public.header.
 *
 * Do not edit this file manually! Always use [com.dbobjekts.codegen.CodeGenerator] when the metadata model is no longer in sync with the database.           
 *
 * Primary keys: id
 *
 * Foreign keys to: 
 * References by: public.record
 */
object Header:Table<HeaderRow>("header"), HasUpdateBuilder<HeaderUpdateBuilder, HeaderInsertBuilder> {
    /**
     * Represents db column public.header.id
     */
    val id = AutoKeyLongColumn(this, "id")
    /**
     * Represents db column public.header.key
     */
    val key = NullableVarcharColumn(this, "key")
    /**
     * Represents db column public.header.value
     */
    val value = NullableVarcharColumn(this, "value")
    /**
     * Represents db column public.header.native
     */
    val nativeHeader = NullableBooleanColumn(this, "native")
    /**
     * Represents db column public.header.record_id
     *
     * Foreign key to public.record.id
     */
    val recordId = ForeignKeyLongColumn(this, "record_id", Record.id)
    override val columns: List<AnyColumn> = listOf(id,key,value,nativeHeader,recordId)
    override fun toValue(values: List<Any?>) = HeaderRow(values[0] as Long,values[1] as String?,values[2] as String?,values[3] as Boolean?,values[4] as Long)
    override fun metadata(): WriteQueryAccessors<HeaderUpdateBuilder, HeaderInsertBuilder> = WriteQueryAccessors(HeaderUpdateBuilder(), HeaderInsertBuilder())
}

class HeaderUpdateBuilder() : UpdateBuilderBase(Header) {
    fun key(value: String?): HeaderUpdateBuilder = put(Header.key, value)
    fun value(value: String?): HeaderUpdateBuilder = put(Header.value, value)
    fun nativeHeader(value: Boolean?): HeaderUpdateBuilder = put(Header.nativeHeader, value)
    fun recordId(value: Long): HeaderUpdateBuilder = put(Header.recordId, value)
    
    /**
     * FOR INTERNAL USE ONLY
     */
    override fun updateRow(rowData: TableRowData<*, *>): Long {
      rowData as HeaderRow
      add(Header.id, rowData.id)
      add(Header.key, rowData.key)
      add(Header.value, rowData.value)
      add(Header.nativeHeader, rowData.nativeHeader)
      add(Header.recordId, rowData.recordId)
      return where(Header.id.eq(rowData.id))
    }    
        
}

class HeaderInsertBuilder():InsertBuilderBase(){
    fun key(value: String?): HeaderInsertBuilder = put(Header.key, value)
    fun value(value: String?): HeaderInsertBuilder = put(Header.value, value)
    fun nativeHeader(value: Boolean?): HeaderInsertBuilder = put(Header.nativeHeader, value)
    fun recordId(value: Long): HeaderInsertBuilder = put(Header.recordId, value)

    fun mandatoryColumns(recordId: Long) : HeaderInsertBuilder {
      mandatory(Header.recordId, recordId)
      return this
    }


    override fun insertRow(rowData: TableRowData<*, *>): Long {
      rowData as HeaderRow
      add(Header.key, rowData.key)
      add(Header.value, rowData.value)
      add(Header.nativeHeader, rowData.nativeHeader)
      add(Header.recordId, rowData.recordId)
      return execute()
    }    
        
}


data class HeaderRow(
val id: Long = 0,
  val key: String?,
  val value: String?,
  val nativeHeader: Boolean?,
  val recordId: Long    
) : TableRowData<HeaderUpdateBuilder, HeaderInsertBuilder>(Header.metadata()){
     override val primaryKeys = listOf<Pair<AnyColumn, Any?>>(Pair(Header.id, id))
}
        
